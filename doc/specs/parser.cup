package compiler.syntax;

// Declaración de importaciones
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:

SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
ScopeManagerIF scopeManager = CompilerContext.getScopeManager ();
FinalCodeFactoryIF finalCodeFactory = CompilerContext.getFinalCodeFactory ();

:}

parser code {:
SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();

public void syntax_error(Symbol symbol)
{
Token token = (Token) symbol.value;
syntaxErrorManager.syntaxError ("Error sintactico, lexema:" + token.getLexema(), token);
}

public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
{
Token token = (Token) symbol.value;
syntaxErrorManager.syntaxFatalError ("Error fatal", token);
}
:}



// Declaración de terminales
terminal Token IDENTIFIER;
terminal Token NUMBER;
terminal Token STRING;
//terminal Token AND;// No implementado: grupo A
terminal Token ARRAY;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONSTANT;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IF;
terminal Token IN;
terminal Token INTEGER;
terminal Token IS;
terminal Token LOOP;
terminal Token OF;
terminal Token OR;
//terminal Token OUT;// No implementado: grupo A
terminal Token PROCEDURE;
terminal Token PUTLINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
//terminal Token WHILE; // No implementado: grupo A
terminal Token BACKSLASH;
terminal Token LEFTBRACKET;
terminal Token RIGHTBRACKET;
terminal Token DOUBLEPOINT;
terminal Token COMMA;
terminal Token SEMICOLON;
terminal Token COLON;
terminal Token PLUS;
//terminal Token MINUS; // No implementado: grupo A
//terminal Token LESSTHAN;// No implementado: grupo A
terminal Token GREATTHAN;
terminal Token EQUAL;
//terminal Token NOTEQUAL;// No implementado: grupo A
terminal Token ASSIGN;
terminal Token POINT;



// Declaración de no terminales
// no modificar los propuestos

non terminal program;
non terminal Axiom axiom;
non terminal declaraciones;
non terminal listasentencias;
non terminal seccionConstantes;
non terminal seccionTiposGlobales;
non terminal seccionVarGlobales;
non terminal seccionSubprogramas;
non terminal declaracionConstante;
non terminal declaracionConstantes;
non terminal valorConstante;
non terminal declaracionTipoGlobal;
non terminal tipoPrimitivo;
non terminal listaIdentificadores;
non terminal declaracionVarGlobal;
non terminal sentencia;
non terminal sentenciaIO;
non terminal listaCamposRegistro;
non terminal campoRegistro;

non terminal listaexpresiones;
non terminal parteexpresion;
non terminal expresionAccesoRegistro;
non terminal expresionInvocaFuncion;
non terminal declaracionSubprograma;
non terminal listaParametros;
non terminal tipoRetorno;
non terminal declaracionesSubprograma;
non terminal bloqueSentencias;
non terminal sentenciaAsignacion;
non terminal sentenciaIf;
non terminal sentenciaWhile;
non terminal sentenciaFor;
non terminal sentenciaInvocaProc;

non terminal invocaProcedimiento;
non terminal parametro;
non terminal expresion;
non terminal expresionAritmetica;
non terminal expresionLogica;
non terminal expresionRegistro;
non terminal empty;




// Declaración de relaciones de precedencia
precedence left POINT, LEFTBRACKET, RIGHTBRACKET;
precedence left PLUS;
precedence left GREATTHAN;
precedence left EQUAL;
precedence left OR;

// Declaración de reglas de producción


start with program;

program ::=
  {:
        syntaxErrorManager.syntaxInfo ("Starting parsing...");
   :}
  axiom:ax
  {:
   // No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  
   //List intermediateCode = ax.getIntermediateCode ();
   //finalCodeFactory.create (intermediateCode);

  
   syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= ;

axiom ::= PROCEDURE IDENTIFIER LEFTBRACKET RIGHTBRACKET IS declaraciones BEGIN listasentencias END IDENTIFIER SEMICOLON;

declaraciones ::= seccionConstantes | seccionTiposGlobales | seccionVarGlobales | seccionSubprogramas | empty;

listaIdentificadores ::= listaIdentificadores COMMA IDENTIFIER | IDENTIFIER;

// Declaración de constantes simbólicas
seccionConstantes ::= declaracionConstante | seccionConstantes declaracionConstante;
declaracionConstante ::= listaIdentificadores COLON CONSTANT ASSIGN valorConstante SEMICOLON;
valorConstante ::= TRUE | FALSE | NUMBER;

// Declaración de tipos globales
//seccionTiposGlobales 	::= declaracionTipoGlobal | seccionTiposGlobales declaracionTipoGlobal;
//declaracionTipoGlobal 	::= TYPE IDENTIFIER IS RECORD listaCamposRegistro END RECORD SEMICOLON;
//listaCamposRegistro		::= campoRegistro SEMICOLON| listaCamposRegistro campoRegistro SEMICOLON;
//campoRegistro			::= IDENTIFIER COLON tipoPrimitivo;

// Declaración de variables globales
seccionVarGlobales		::= declaracionVarGlobal | seccionVarGlobales declaracionVarGlobal;
declaracionVarGlobal	::= listaIdentificadores COLON tipoPrimitivo SEMICOLON;
tipoPrimitivo 			::= INTEGER | BOOLEAN; 

// Lista de sentencias
listasentencias ::= sentencia SEMICOLON | listasentencias sentencia SEMICOLON;
//sentencia		::= sentenciaAsignacion | sentenciaIf | sentenciaWhile | sentenciaFor | sentenciaInvocaProc	| sentenciaIO | empty;
sentencia		::= sentenciaAsignacion | sentenciaIO | empty;


// Expresiones
//listaexpresiones	::= listaexpresiones parteexpresion | parteexpresion;
//expresion		::=	expresionAritmetica | expresionLogica | expresionAccesoRegistro | expresionInvocaFuncion;

expresion	::= expresionAritmetica | expresionLogica;
expresionAritmetica ::= LEFTBRACKET expresionAritmetica RIGHTBRACKET 
						|expresionAritmetica PLUS expresionAritmetica 
						| NUMBER 
						| IDENTIFIER;

expresionLogica		::= expresionLogica OR expresionLogica 
						| expresionAritmetica GREATTHAN expresionAritmetica
						| expresionAritmetica EQUAL expresionAritmetica
						| TRUE 
						| FALSE;
						
 
// Sentencia IO
sentenciaIO 	::= PUTLINE LEFTBRACKET parametro RIGHTBRACKET;
parametro		::= expresionAritmetica | expresionLogica | STRING;
//Sentencia Asignacion
sentenciaAsignacion	::= IDENTIFIER ASSIGN expresionAritmetica | IDENTIFIER ASSIGN expresionLogica;  

empty ::= ;