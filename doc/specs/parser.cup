package compiler.syntax;

// Declaración de importaciones
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:

SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
ScopeManagerIF scopeManager = CompilerContext.getScopeManager ();
FinalCodeFactoryIF finalCodeFactory = CompilerContext.getFinalCodeFactory ();

:}

parser code {:
SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();

public void syntax_error(Symbol symbol)
{
Token token = (Token) symbol.value;
syntaxErrorManager.syntaxError ("Error sintactico, lexema:" + token.getLexema(), token);
}

public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
{
Token token = (Token) symbol.value;
syntaxErrorManager.syntaxFatalError ("Error fatal", token);
}
:}



// Declaración de terminales
terminal Token IDENTIFIER;
terminal Token NUMBER;
terminal Token STRING;
//terminal Token AND;		// No implementado: grupo A
//terminal Token ARRAY;		// No implementado: grupo A
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONSTANT;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IF;
terminal Token IN;
terminal Token INTEGER;
terminal Token IS;
terminal Token LOOP;
//terminal Token OF;		// No implementado: grupo A
terminal Token OR;
//terminal Token OUT;		// No implementado: grupo A
terminal Token PROCEDURE;
terminal Token PUTLINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
//terminal Token WHILE; 	// No implementado: grupo A
 terminal Token BACKSLASH; 
// ?¿?¿?¿?¿?¿?¿? backslash ¿?¿?¿ 

terminal Token LEFTBRACKET;
terminal Token RIGHTBRACKET;
terminal Token DOUBLEPOINT;
terminal Token COMMA;
terminal Token SEMICOLON;
terminal Token COLON;
terminal Token PLUS;
//terminal Token MINUS; // No implementado: grupo A
//terminal Token LESSTHAN;// No implementado: grupo A
terminal Token GREATTHAN;
terminal Token EQUAL;
//terminal Token NOTEQUAL;// No implementado: grupo A
terminal Token ASSIGN;
terminal Token POINT;



// Declaración de no terminales
// no modificar los propuestos

non terminal program;
non terminal Axiom axiom;
non terminal Declaraciones declaraciones;
non terminal BloqueSentencias bloqueSentencias;
non terminal SeccionConstantes seccionConstantes;
non terminal SeccionTipos seccionTipos;
non terminal SeccionVariables seccionVariables;
non terminal SeccionSubprogramas seccionSubprogramas;
non terminal SeccionCuerpoPrograma seccionCuerpoPrograma;
non terminal DeclaracionConstante declaracionConstante;
non terminal DeclaracionTipos declaracionTipos;
non terminal DeclaracionVariables declaracionVariables;
non terminal DeclaracionSubprogramas declaracionSubprogramas;
non terminal BloqueParamSubprograma bloqueParamSubprograma;
non terminal ValorConstante valorConstante;
non terminal TipoPrimitivo tipoPrimitivo;
non terminal ListaIdentificadores listaIdentificadores;
non terminal Sentencia sentencia;
non terminal SentenciaIO sentenciaIO;
non terminal SentenciaAsignacion sentenciaAsignacion;
non terminal SentenciaIf sentenciaIf;
non terminal SentenciaReturn sentenciaReturn;
non terminal SentenciaLlamadaSubprograma sentenciaLlamadaSubprograma;
non terminal SentenciaFor sentenciaFor;
non terminal BloqueCamposRegistro bloqueCamposRegistro;
non terminal CampoRegistro campoRegistro;
non terminal ExpresionAccesoRegistro expresionAccesoRegistro;
non terminal Parametro parametro;
non terminal Expresion expresion;
non terminal ExpresionAritmetica expresionAritmetica;
non terminal ExpresionLogica expresionLogica;
non terminal ListaParametros listaParametros;
non terminal Empty empty;




// Declaración de relaciones de precedencia
precedence left POINT, LEFTBRACKET, RIGHTBRACKET;
precedence left PLUS;
precedence left GREATTHAN;
precedence left EQUAL;
precedence left OR;

// Declaración de reglas de producción


start with program;

program ::=
  {:
        syntaxErrorManager.syntaxInfo ("Starting parsing...");
   :}
  axiom:ax
  {:
   // No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  
   //List intermediateCode = ax.getIntermediateCode ();
   //finalCodeFactory.create (intermediateCode);

  
   syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= ;

axiom ::= PROCEDURE IDENTIFIER:id 
			{:
				//Creación del ámbito inicial del programa
				String name = id.getLexema();
				scopeManager.openScope(name);
				ScopeIF scope = scopeManager.getCurrentScope();
				semanticErrorManager.semanticDebug("El nombre del scope creado es: " + scope.getName());
				
				//Obtenemos la tabla de tipos del ámbito actual
				TypeTableIF tablaTipos = scope.getTypeTable();
				semanticErrorManager.semanticDebug("Tabla de tipos obtenida, pertenece al scope/ámbito: " + tablaTipos.getScope().getName() + " y tiene tamaño: " + tablaTipos.getSize()); 
				
				//Insertar todos los TypeSimple en la Tabla de Tipos
				TypeSimple typeBoolean = new TypeSimple(scope);
				TypeSimple typeInteger = new TypeSimple(scope);
				tablaTipos.addType("Boolean", typeBoolean);
				tablaTipos.addType("Integer", typeInteger); 
				semanticErrorManager.semanticDebug("Tabla de tipos obtenida del scope/ámbito: " + tablaTipos.getScope().getName() + " y tiene tamaño: " + tablaTipos.getSize());
				
				//scopeManager.closeScope();
				//semanticErrorManager.semanticDebug("Scope cerrado: " + scope.getName());
			:}  LEFTBRACKET RIGHTBRACKET IS declaraciones:d;
//		  | PROCEDURE IDENTIFIER LEFTBRACKET error RIGHTBRACKET IS declaraciones{:syntaxErrorManager.syntaxInfo("ERROR 00x: Estructura programa - Procedimiento principal no puede tener parámetros");:}
//		  | PROCEDURE IDENTIFIER LEFTBRACKET RIGHTBRACKET error declaraciones {:syntaxErrorManager.syntaxInfo("ERROR 001: Estructura programa, falta IS");:};
//		  | error {:syntaxErrorManager.syntaxInfo("ERROR 00X: Error general estructura programa");:};

//declaraciones ::= seccionConstantes seccionTiposGlobales seccionVarGlobales | empty;
declaraciones				::=	seccionConstantes;
seccionConstantes 			::= declaracionConstante seccionConstantes | seccionTipos;
seccionTipos				::= declaracionTipos seccionTipos | seccionVariables;
seccionVariables			::= declaracionVariables seccionVariables | seccionSubprogramas;
seccionSubprogramas			::= declaracionSubprogramas seccionSubprogramas | seccionCuerpoPrograma;
seccionCuerpoPrograma		::= BEGIN bloqueSentencias END IDENTIFIER SEMICOLON
								|BEGIN bloqueSentencias END error SEMICOLON {:syntaxErrorManager.syntaxInfo("ERROR 002: Estructura programa, falta NOMBRE_PROGRAMA en sentencia END");:}
								| error {:syntaxErrorManager.syntaxInfo("ERROR 003: Estructura programa");:};
								

listaIdentificadores ::= listaIdentificadores:lid COMMA IDENTIFIER:id
						{:
							//Verificamos si el identificador está en la tabla de símbolos
							
							//Añadimos identificador a lista de identificadores
							lid.addIdentifier(id);
							RESULT=lid;					
						:}
						  | IDENTIFIER:id
						  {:	//Creamos lista de identificadores, e insertamos el primer elemento id.
						  	
						  	ListaIdentificadores listaid = new ListaIdentificadores();
						  	semanticErrorManager.semanticDebug("Tras creación listaIdentificadores. Size = " + listaid.getSize());
						  	listaid.addIdentifier(id);
						  	semanticErrorManager.semanticDebug("Tras añadir identificador: " + id.getLexema() + ", listaIdentificadores. Size = " + listaid.getSize() );
						  	RESULT=listaid;
						  :};

// Declaración de constantes simbólicas
declaracionConstante ::= listaIdentificadores:lid COLON CONSTANT ASSIGN valorConstante:vc SEMICOLON 
							{:syntaxErrorManager.syntaxDebug("En declaración constante");
							
								//	Obtenemos ámbito actual
								ScopeIF scope = scopeManager.getCurrentScope();
								semanticErrorManager.semanticDebug("Scope actual, nombre:" + scope.getName());
								// Obtenemos la tabla de símbolos del ámbito actual, y verificamos si los identificadores de la lista están ya definidos en la TS
								SymbolTableIF tablaSimbolos = scope.getSymbolTable();
								semanticErrorManager.semanticDebug("Tabla símbolos del scope:" + scope.getName() + " obtenida. Tamaño TS: " + tablaSimbolos.getSize());
								ArrayList<Token> identifiersList = lid.getIdentifiersList();
								semanticErrorManager.semanticDebug("Tras obtener lista de Identificadores como ArrayList. Tamaño ArrayList=" + identifiersList.size());
								for(int i = 0; i<identifiersList.size(); i++){
									if(tablaSimbolos.containsSymbol(identifiersList.get(i).getLexema()))
										semanticErrorManager.semanticFatalError("Error en declaración constante, ya existe declaración de " + identifiersList.get(i).getLexema());
									else{	//SymbolConstant(scope, name, type)
										TypeSimple tipoSimple = new TypeSimple(scope);
										SymbolConstant symbolconstant = new SymbolConstant(scope, identifiersList.get(i).getLexema(), tipoSimple);
										tablaSimbolos.addSymbol(symbolconstant);
									}
								}
								
								
												
							:};
// 						 | listaIdentificadores COLON CONSTANT error valorConstante {:syntaxErrorManager.syntaxInfo("ERROR 00x: Error en declaración constantes, operador asignación");:}
//						 | listaIdentificadores COLON CONSTANT ASSIGN error {:syntaxErrorManager.syntaxInfo("ERROR 00x: Error en declaración constantes, valor incorrecto");:}
//						 | listaIdentificadores COLON CONSTANT ASSIGN valorConstante error SEMICOLON{:syntaxErrorManager.syntaxInfo("ERROR 00x: Error en declaración constantes, falta punto y coma");:};
						 				 
						 
valorConstante ::= TRUE | FALSE | NUMBER;

// Declaración de tipos globales
declaracionTipos 		::= TYPE IDENTIFIER IS RECORD bloqueCamposRegistro END RECORD SEMICOLON;
bloqueCamposRegistro	::= campoRegistro SEMICOLON| bloqueCamposRegistro campoRegistro SEMICOLON;
campoRegistro			::= IDENTIFIER COLON tipoPrimitivo;
//ERROR: El tipo de un registro también puede ser otro registro, no sólo Integer y Boolean
 
// Declaración de variables globales
declaracionVariables	::= listaIdentificadores COLON tipoPrimitivo SEMICOLON;
tipoPrimitivo 			::= INTEGER | BOOLEAN | IDENTIFIER; 

// Declaración de subprogramas
declaracionSubprogramas		::= FUNCTION IDENTIFIER LEFTBRACKET bloqueParamSubprograma RIGHTBRACKET RETURN tipoPrimitivo IS seccionTipos 
								| PROCEDURE IDENTIFIER LEFTBRACKET bloqueParamSubprograma RIGHTBRACKET IS seccionTipos
								| FUNCTION IDENTIFIER LEFTBRACKET bloqueParamSubprograma RIGHTBRACKET error IS {:syntaxErrorManager.syntaxInfo("ERROR 00x: Error definición función, falta return");:};


bloqueParamSubprograma		::= bloqueParamSubprograma SEMICOLON listaIdentificadores COLON tipoPrimitivo
								| listaIdentificadores COLON tipoPrimitivo
								| empty;

// Bloque de sentencias
bloqueSentencias			::= sentencia SEMICOLON bloqueSentencias 
								| empty;								

sentencia		::= expresion | sentenciaAsignacion | sentenciaIf | sentenciaIO | sentenciaReturn | sentenciaFor;


// Expresiones
expresion	::= expresionAritmetica 
				| expresionLogica 
				| expresionAccesoRegistro 
				| LEFTBRACKET expresion RIGHTBRACKET
				| IDENTIFIER;

expresionAritmetica ::= expresion:e1 PLUS expresion:e2
							{:
								ExpresionAritmetica e = new ExpresionAritmetica(e1, e2);
								//Comprobación de tipos sobre e1 y e2
								//Recuperamos tipos de e1 y e2
//								TypeIF t1 = 
//								TypeIF t2 = 
//								semanticErrorManager.semanticDebug("Expresión Aritmética - Tipo de e1: " + t1);
//								semanticErrorManager.semanticDebug("Expresión Aritmética - Tipo de e2: " + t2);
//								if (t1.isCompatible (t2, TypeIF.PLUS))
//								{
//								}
//								else semanticErrorManager.semanticFatalError ("Expresión Aritmética - Tipos incompatibles");
//								//Comprobamos compatibilidad de t1 y t2 para PLUS
														
								//Generación de código para e1 + e2							
								RESULT = e; 
							:} 
						| NUMBER; 

expresionLogica		::= expresion:e1 OR expresion:e2
							{:
								ExpresionLogica e = new ExpresionLogica(e1, e2);
								//Comprobación de tipos sobre e1 y e2
								//Generación de código para e1 OR e2							
								RESULT = e;
							:} 
						| expresion:e1 GREATTHAN expresion:e2
							{:
								ExpresionLogica e = new ExpresionLogica(e1, e2);
								//Comprobación de tipos sobre e1 y e2
								//Generación de código para e1 > e2
								RESULT = e;
							:}
						| expresion:e1 EQUAL expresion:e2
							{:
								ExpresionLogica e = new ExpresionLogica(e1, e2);
								//Comprobación de tipos sobre e1 y e2
								//Generación de código para e1 = e2
								RESULT=e;
							:}
						| sentenciaLlamadaSubprograma
						| TRUE 
						| FALSE;
						

expresionAccesoRegistro		::= IDENTIFIER POINT expresionAccesoRegistro | IDENTIFIER POINT IDENTIFIER;  
			
 
// Sentencia IO
sentenciaIO 	::= PUTLINE LEFTBRACKET parametro RIGHTBRACKET;
parametro		::= expresion | STRING;

//Sentencia Asignacion
sentenciaAsignacion		::= IDENTIFIER ASSIGN expresion
							| expresionAccesoRegistro ASSIGN expresion;  
						

//Sentencia If
sentenciaIf			::= IF expresion THEN bloqueSentencias END IF | IF expresion THEN bloqueSentencias ELSE bloqueSentencias END IF;

// Sentencia de retorno de función
sentenciaReturn	::= RETURN expresion;

// Sentencia de llamada a subprograma
sentenciaLlamadaSubprograma	::= IDENTIFIER LEFTBRACKET listaParametros RIGHTBRACKET;
listaParametros				::= listaParametros COMMA expresion | expresion | empty;


// Sentencia For
sentenciaFor	::=	FOR IDENTIFIER IN expresion DOUBLEPOINT expresion LOOP bloqueSentencias END LOOP;

empty ::= ;