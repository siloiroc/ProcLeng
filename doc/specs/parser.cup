package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico, lexema:" + token.getLexema(), token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
		Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}



// Declaración de terminales
terminal Token IDENTIFIER;
terminal Token NUMBER;
terminal Token STRING;
	//terminal Token AND;// No implementado: grupo A
terminal Token ARRAY;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONSTANT;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IF;
terminal Token IN;
terminal Token INTEGER;
terminal Token IS;
terminal Token LOOP;
terminal Token OF;
terminal Token OR;
	//terminal Token OUT;// No implementado: grupo A
terminal Token PROCEDURE;
terminal Token PUTLINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
	//terminal Token WHILE; // No implementado: grupo A 
terminal Token BACKSLASH;
terminal Token LEFTBRACKET;
terminal Token RIGHTBRACKET;
terminal Token DOUBLEPOINT;
terminal Token COMMA;
terminal Token SEMICOLON;
terminal Token COLON;
terminal Token PLUS;
	//terminal Token MINUS;	// No implementado: grupo A
	//terminal Token LESSTHAN;// No implementado: grupo A
terminal Token GREATTHAN;
terminal Token EQUAL;
	//terminal Token NOTEQUAL;// No implementado: grupo A
terminal Token ASSIGN;
terminal Token ACCESS;



// Declaración de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;
non terminal			declaraciones;
non terminal			listasentencias;
non terminal			declaracionConstantes;
non terminal 			declaracionConstante;
non terminal			declaracionTiposGlobales;
non terminal 			declaracionTipoGlobal;
non terminal			declaracionVarGlobales;
non terminal 			declaracionVarGlobal;
non terminal			declaracionSubprogramas;
non terminal 			declaracionSubprograma;
non terminal 			listaParametros;
non terminal			tipoRetorno;
non terminal 			declaracionesSubprograma;
non terminal 			bloqueSentencias;
non terminal			sentenciaAsignacion;
non terminal			sentenciaIf;
non terminal			sentenciaWhile;
non terminal			sentenciaFor;
non terminal			sentenciaIO;
non terminal			invocaProcedimiento;
non terminal			sentencia;
non terminal			listaDeclaracionConstantes;
non terminal			listaDeclaracionVariables;
non terminal			parametro;
non terminal			expresion;
non terminal			expresionAritmetica;
non terminal			expresionLogica;
non terminal			expresionRegistro;
non terminal			empty;
non terminal			tipoPrimitivo;


// Declaración de relaciones de precedencia
precedence left     PLUS,
                    MINUS;
// ...

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);

  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= ;

axiom ::= PROCEDURE IDENTIFIER LEFTBRACKET RIGHTBRACKET IS declaraciones BEGIN listasentencias END IDENTIFIER SEMICOLON;

declaraciones ::= declaracionConstantes | declaracionTiposGlobales | declaracionVarGlobales | empty;

declaracionConstantes		::= listaDeclaracionConstantes;
listaDeclaracionConstantes  ::= declaracionConstante | listaDeclaracionConstantes declaracionConstante;
declaracionVarGlobales		::= listaDeclaracionVariables;
listaDeclaracionVariables	::= declaracionVarGlobal | listaDeclaracionVariables declaracionVarGlobal;
//declaracionTiposGlobales 	::= declaracionTipoGlobal | declaracionTiposGlobales declaracionTipoGlobal;
//declaracionSubprogramas 	::= declaracionSubprograma | declaracionSubprogramas declaracionSubprograma;

declaracionConstante ::= IDENTIFIER COLON CONSTANT ASSIGN NUM SEMICOLON 
							| IDENTIFIER COLON CONSTANT ASSIGN TRUE SEMICOLON 
							| IDENTIFIER COLON CONSTANT ASSIGN FALSE SEMICOLON;
declaracionVarGlobal ::= IDENTIFIER COLON tipoPrimitivo SEMICOLON;
tipoPrimitivo			::= INTEGER | BOOLEAN;
listasentencias ::= sentenciaIO listasentencias | sentenciaAsignacion listasentencias| sentenciaIf listasentencias| sentenciaWhile listasentencias| empty;
sentenciaAsignacion	::= IDENTIFIER ASSIGN expresion SEMICOLON;
sentenciaIf			::= IF expresion THEN listasentencias END IF SEMICOLON 
						| IF expresion THEN listasentencias ELSE listasentencias END IF SEMICOLON;

empty ::= ;

//expresion	::= expresionAritmetica | expresionLogica | IDENTIFIER;
expresion ::= expresionLogica;
//expresionAritmetica ::= expresionAritmetica PLUS expresionAritmetica
//						| LEFTBRACKET expresionAritmetica RIGHTBRACKET
//						| NUM ; 
expresionLogica 	::= expresionLogica OR expresionLogica | 
						| LEFTBRACKET expresionAritmetica RIGHTBRACKET 
						|TRUE | FALSE;  

sentenciaIO ::= PUTLINE LEFTBRACKET parametro RIGHTBRACKET SEMICOLON;
//parametro	::= STRING | expresion;

