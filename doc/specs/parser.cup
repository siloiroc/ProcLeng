package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.semantic.util.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
		Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales (Ejemplo)

terminal Token IDENTIFIER;
terminal Token NUMBER;
terminal Token STRING;
//terminal Token AND;		// No implementado: grupo A
//terminal Token ARRAY;		// No implementado: grupo A
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONSTANT;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IF;
terminal Token IN;
terminal Token INTEGER;
terminal Token IS;
terminal Token LOOP;
//terminal Token OF;		// No implementado: grupo A
terminal Token OR;
//terminal Token OUT;		// No implementado: grupo A
terminal Token PROCEDURE;
terminal Token PUTLINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
//terminal Token WHILE; 	// No implementado: grupo A
 terminal Token BACKSLASH; 
// ?¿?¿?¿?¿?¿?¿? backslash ¿?¿?¿ 

terminal Token LEFTBRACKET;
terminal Token RIGHTBRACKET;
terminal Token DOUBLEPOINT;
terminal Token COMMA;
terminal Token SEMICOLON;
terminal Token COLON;
terminal Token PLUS;
//terminal Token MINUS; // No implementado: grupo A
//terminal Token LESSTHAN;// No implementado: grupo A
terminal Token GREATTHAN;
terminal Token EQUAL;
//terminal Token NOTEQUAL;// No implementado: grupo A
terminal Token ASSIGN;
terminal Token POINT;


// Declaración de no terminales
// no modificar los propuestos

non terminal program;
non terminal Axiom axiom;
non terminal Declaraciones declaraciones;
non terminal BloqueSentencias bloqueSentencias;
non terminal SeccionConstantes seccionConstantes;
non terminal SeccionTipos seccionTipos;
non terminal SeccionVariables seccionVariables;
non terminal SeccionSubprogramas seccionSubprogramas;
non terminal SeccionCuerpoPrograma seccionCuerpoPrograma;
non terminal DeclaracionConstante declaracionConstante;
non terminal DeclaracionTipo declaracionTipo;
non terminal DeclaracionVariable declaracionVariable;
non terminal DeclaracionSubprograma declaracionSubprograma;
non terminal BloqueParamSubprograma bloqueParamSubprograma;
non terminal ValorConstante valorConstante;
non terminal TipoPrimitivo tipoPrimitivo;
non terminal Tipo tipo;
non terminal TipoRegistro tipoRegistro;
non terminal ListaIdentificadores listaIdentificadores;
non terminal Sentencia sentencia;
non terminal SentenciaIO sentenciaIO;
non terminal SentenciaAsignacion sentenciaAsignacion;
non terminal SentenciaIf sentenciaIf;
non terminal SentenciaReturn sentenciaReturn;
non terminal SentenciaLlamadaSubprograma sentenciaLlamadaSubprograma;
non terminal SentenciaFor sentenciaFor;
non terminal BloqueCamposRegistro bloqueCamposRegistro;
non terminal CampoRegistro campoRegistro;
non terminal ExpresionAccesoRegistro expresionAccesoRegistro;
non terminal Expresion expresion;
non terminal ExpresionAritmetica expresionAritmetica;
non terminal ExpresionLogica expresionLogica;
non terminal ListaParametros listaParametros;
non terminal Empty empty;
non terminal Referencia referencia;

// Declaración de relaciones de precedencia
precedence left POINT, LEFTBRACKET, RIGHTBRACKET;
precedence left PLUS;
precedence left GREATTHAN;
precedence left EQUAL;
precedence left OR;

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);

  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= ;


axiom ::= PROCEDURE IDENTIFIER:id
			{:
			//Creación del ámbito global del programa
				String name = id.getLexema();
				scopeManager.openScope(name);
				ScopeIF scope = scopeManager.getCurrentScope();
				semanticErrorManager.semanticDebug("El nombre del scope creado es: " + scope.getName());
				
				//Obtenemos la tabla de tipos del ámbito actual
				TypeTableIF tablaTipos = scope.getTypeTable();
				semanticErrorManager.semanticDebug("Tabla de tipos obtenida, pertenece al scope/ámbito: " + tablaTipos.getScope().getName() + " y tiene tamaño: " + tablaTipos.getSize()); 
				
				//Insertar todos los TypeSimple en la Tabla de Tipos
				TypeSimple typeBoolean = new TypeSimple(scope, "Boolean");
				TypeSimple typeInteger = new TypeSimple(scope, "Integer");
				tablaTipos.addType("BOOLEAN", typeBoolean);
				tablaTipos.addType("INTEGER", typeInteger); 
				semanticErrorManager.semanticDebug("Tabla de tipos obtenida del scope/ámbito: " + tablaTipos.getScope().getName() + " y tiene tamaño: " + tablaTipos.getSize());
				List<TypeIF> listaTipos = tablaTipos.getTypes();
				semanticErrorManager.semanticDebug("TT contiente tipo Boolean??" + tablaTipos.containsType("Boolean"));
					semanticErrorManager.semanticDebug("TT contiente tipo Integer??" + tablaTipos.containsType("Integer"));
					semanticErrorManager.semanticDebug("TT contiente tipo Pepe??" + tablaTipos.containsType("Pepe"));
				for (int i=0; i<listaTipos.size(); i++){
					semanticErrorManager.semanticDebug("Nombre de tipo: " + listaTipos.get(i).getName());
				}
				
				//scopeManager.closeScope();
				//semanticErrorManager.semanticDebug("Scope cerrado: " + scope.getName());
			:} LEFTBRACKET RIGHTBRACKET IS declaraciones:d;
//		  | PROCEDURE IDENTIFIER LEFTBRACKET error RIGHTBRACKET IS declaraciones{:syntaxErrorManager.syntaxInfo("ERROR 00x: Estructura programa - Procedimiento principal no puede tener parámetros");:}
//		  | PROCEDURE IDENTIFIER LEFTBRACKET RIGHTBRACKET error declaraciones {:syntaxErrorManager.syntaxInfo("ERROR 001: Estructura programa, falta IS");:};
//		  | error {:syntaxErrorManager.syntaxInfo("ERROR 00X: Error general estructura programa");:};

//declaraciones ::= seccionConstantes seccionTiposGlobales seccionVarGlobales | empty;
declaraciones				::=	seccionConstantes;
seccionConstantes 			::= declaracionConstante seccionConstantes | seccionTipos;
seccionTipos				::= declaracionTipo seccionTipos | seccionVariables;
seccionVariables			::= declaracionVariable SEMICOLON seccionVariables | seccionSubprogramas;
seccionSubprogramas			::= declaracionSubprograma seccionSubprogramas | seccionCuerpoPrograma;
seccionCuerpoPrograma		::= BEGIN 
								{: semanticErrorManager.semanticDebug("*******************Inicio BloqueSentencias*******************"); :}
								bloqueSentencias END IDENTIFIER SEMICOLON
								{:
									semanticErrorManager.semanticDebug("*******************Fin BloqueSentencias************************");
								:};
//								|BEGIN bloqueSentencias END error SEMICOLON {:syntaxErrorManager.syntaxInfo("ERROR 002: Estructura programa, falta NOMBRE_PROGRAMA en sentencia END");:}
//								| error {:syntaxErrorManager.syntaxInfo("ERROR 003: Estructura programa");:};
								

listaIdentificadores ::= listaIdentificadores:idlist COMMA IDENTIFIER:id
						{:
							String name = id.getLexema();
							//Verificamos si el identificador está en la tabla de símbolos
							if(scopeManager.containsSymbol(name)){
								//Si existe el símbolo en ámbitos abiertos, lo obtenemos,
								SymbolIF sym = scopeManager.searchSymbol(name);
								if (sym instanceof SymbolConstant){
									SymbolConstant symconst = (SymbolConstant)sym;
									Object value = symconst.getValue();
									//RESULT = new RNumero(value);
								}
								else
									semanticErrorManager.semanticFatalError("Símbolo no es de tipo SymbolConstant");
							}
							else{
								//Añadimos identificador a lista de identificadores
								idlist.addIdentifier(id.getLexema());
								RESULT=idlist;
								}					
						:}
						  | IDENTIFIER:id
						  {:	
						  	//Creamos lista de identificadores, e insertamos el primer elemento id.
						  	ListaIdentificadores idlist = new ListaIdentificadores();
						  	idlist.addIdentifier(id.getLexema());
						  	RESULT=idlist;
						  :};


// Declaración de constantes simbólicas
declaracionConstante ::= listaIdentificadores:lid COLON CONSTANT ASSIGN valorConstante:vc SEMICOLON 
							{:syntaxErrorManager.syntaxDebug("En declaración constante");
							
								//	Obtenemos ámbito actual
								ScopeIF scope = scopeManager.getCurrentScope();
								semanticErrorManager.semanticDebug("Scope actual, nombre:" + scope.getName());
								// Obtenemos la tabla de símbolos del ámbito actual
								SymbolTableIF tablaSimbolos = scope.getSymbolTable();
								
								// Obtenemos lista de identificadores
								ArrayList<String> identifiersList = lid.getIdentifiersList();
								
								//Verificamos si los identificadores de la lista están ya definidos en la TS. 
								for(int i = 0; i<identifiersList.size(); i++){
									if(tablaSimbolos.containsSymbol(identifiersList.get(i)))
										semanticErrorManager.semanticFatalError("Error en declaración de Constante, ya existe declaración de " + identifiersList.get(i));
									else{
										// Símbolos no existen en TS, por lo que añadimos cada uno de ellos a la TS.		
										// SymbolConstant(scope, name, type)
										TypeIF typeInTT = scopeManager.searchType("Boolean");
										SymbolConstant symbolconstant = new SymbolConstant(scope, identifiersList.get(i), typeInTT);
										tablaSimbolos.addSymbol(symbolconstant);
									}
								}
							:};
							 
// 						 | listaIdentificadores COLON CONSTANT error valorConstante {:syntaxErrorManager.syntaxInfo("ERROR 00x: Error en declaración constantes, operador asignación");:}
//						 | listaIdentificadores COLON CONSTANT ASSIGN error {:syntaxErrorManager.syntaxInfo("ERROR 00x: Error en declaración constantes, valor incorrecto");:}
//						 | listaIdentificadores COLON CONSTANT ASSIGN valorConstante error SEMICOLON{:syntaxErrorManager.syntaxInfo("ERROR 00x: Error en declaración constantes, falta punto y coma");:};
						 				 
						 
valorConstante ::= TRUE:vc 
						{: 
							ValorConstante value = new ValorConstante(vc.getLexema());
					   		RESULT = value; 
					   :}
				   | FALSE:vc
				   		{:	ValorConstante value = new ValorConstante(vc.getLexema());
				   			RESULT = value; 
				   		:} 
				   | NUMBER:num 
				   	 	{: 	
				   	 		ValorConstante value = new ValorConstante(num.getLexema());
				   	 		RESULT = value;
				   	 	:};
// Declaración de tipos globales
declaracionTipo 		::= TYPE IDENTIFIER:id IS tipoRegistro:tipoReg
							{:
								semanticErrorManager.semanticDebug("**Declaración Tipo: " + id.getLexema() + "******");
								semanticErrorManager.semanticDebug("**********************************");
								// Obtenemos la tabla de tipos del ámbito actual,y verificamos si el tipo está definido ya en TT, si no, lo añadimos
								ScopeIF scope = scopeManager.getCurrentScope();								
								TypeTableIF tablaTipos = scope.getTypeTable();
								if(tablaTipos.containsType(id.getLexema()))
										semanticErrorManager.semanticFatalError("ERROR - Error en declaración de Tipo, ya existe declaración de " + id.getLexema());
								else{ 
									
								}
								semanticErrorManager.semanticDebug("FIN**Declaración Tipo: " + id.getLexema() + "******");
								semanticErrorManager.semanticDebug("**********************************");										
							:};

tipoRegistro			::= RECORD bloqueCamposRegistro:bcr END RECORD SEMICOLON
							{:
								//Creamos nuevo tipo Registro y lo introducimos en la tabla de tipos							
							:};
							
//bloqueCamposRegistro	::= bloqueCamposRegistro:bcr campoRegistro:cr SEMICOLON
//							{:
//								BloqueCamposRegistro bloquecampos = bcr;
//								bloquecampos.addCampoRegistro(cr);
//								RESULT = bloquecampos;
//							:} 
//							| campoRegistro:cr SEMICOLON
//							{:
//								BloqueCamposRegistro bloquecampos = new BloqueCamposRegistro();
//								bloquecampos.addCampoRegistro(cr);
//								RESULT = bloquecampos;
//							:};

bloqueCamposRegistro	::= declaracionVariable SEMICOLON
							| bloqueCamposRegistro declaracionVariable SEMICOLON; 
 
campoRegistro			::= IDENTIFIER:id COLON tipoPrimitivo:tp
							{:	//Campo es de tipo Integer o Boolean	
							//Comprobamos si el simbolo está ya definido en la tabla de símbolos
							
								ScopeIF scope = scopeManager.getCurrentScope();								
								SymbolTableIF tablaSimbolos = scope.getSymbolTable();
								TypeTableIF tablaTipos = scope.getTypeTable();
								
								if(tablaSimbolos.containsSymbol(id.getLexema()))
									semanticErrorManager.semanticFatalError("ERROR T02: Campo de registro: " + id.getLexema() + "ya definido anteriormente");
								else{
									CampoRegistro camporeg = new CampoRegistro(id.getLexema(), tp);
									TypeIF tipo = scopeManager.searchType(tp.getValue());
									SymbolVariable symbolvariable = new SymbolVariable(scope, id.getLexema(), tipo);
									semanticErrorManager.semanticDebug("Después symbolvariable: ");
									semanticErrorManager.semanticDebug("El tipo es: tp.getValue()=" + tp.getValue());
									Util util = new Util();
									util.debugTablesToString(scope);
									
									if(!tablaTipos.containsType(tipo))
									{//Si tipo no existe en tabla de tipos, mostramos error semántico
										semanticErrorManager.semanticFatalError("ERROR T03: Campo de registro: " + id.getLexema() + " de tipo desconocido " + tp.getValue());
									}
									else{	//Añadimos el identificador a la tabla de símbolos, en el ámbito actual
										//CampoRegistro camporeg = new CampoRegistro(id.getLexema(), tp);
										tablaSimbolos.addSymbol(id.getLexema(), symbolvariable);
										RESULT = camporeg;
										}
								}

							:};

// Declaración de variables globales
declaracionVariable		::= listaIdentificadores:lid COLON tipoPrimitivo:tp
							{:	//	Obtenemos ámbito actual
								ScopeIF scope = scopeManager.getCurrentScope();
								semanticErrorManager.semanticDebug("Sección Declaración Variables: Scope actual, nombre:" + scope.getName());
								
								// Obtenemos la tabla de símbolos del ámbito actual, y verificamos si los identificadores de la lista de variables están ya definidos en la TS
								SymbolTableIF tablaSimbolos = scope.getSymbolTable();
								semanticErrorManager.semanticDebug("Sección Variables - Tabla símbolos del scope:" + scope.getName() + " obtenida. Tamaño TS: " + tablaSimbolos.getSize());
								ArrayList<String> identifiersList = lid.getIdentifiersList();
								semanticErrorManager.semanticDebug("Sección Variables - Tras obtener lista de Identificadores como ArrayList. Tamaño ArrayList=" + identifiersList.size());
								semanticErrorManager.semanticDebug("Sección Variables - Tamaño de listadeIdentificadores declaración variables=" + identifiersList.size());
								for(int i = 0; i<identifiersList.size(); i++){
									if(tablaSimbolos.containsSymbol(identifiersList.get(i)))
										semanticErrorManager.semanticFatalError("Error en declaración de Variable, ya existe declaración de " + identifiersList.get(i));
									else{ 
										TypeIF tipo = scopeManager.searchType(tp.getValue());
										SymbolVariable symbolvariable = new SymbolVariable(scope, identifiersList.get(i), tipo);
										tablaSimbolos.addSymbol(symbolvariable);
									}
								}
								semanticErrorManager.semanticDebug("*** FIN Sección Declaración Variables: Scope actual, nombre:" + scope.getName());
							:};

tipo					::= INTEGER
							| BOOLEAN
							| IDENTIFIER;
tipoPrimitivo 			::= INTEGER:tpint
								 {: TipoPrimitivo tipoPrim = new TipoPrimitivo(tpint.getLexema().toUpperCase());
								 	RESULT = tipoPrim;
								 :}
							| BOOLEAN:tpbool
								 {: TipoPrimitivo tipoPrim = new TipoPrimitivo(tpbool.getLexema().toUpperCase());
								 	RESULT = tipoPrim;
								 :}
							| IDENTIFIER:id
								{:	TipoPrimitivo tipoPrim = new TipoPrimitivo("IDENTIFIER");
									RESULT = tipoPrim;
								:};  

// Declaración de subprogramas
declaracionSubprograma		::= FUNCTION IDENTIFIER LEFTBRACKET bloqueParamSubprograma RIGHTBRACKET RETURN tipoPrimitivo IS seccionTipos 
								| PROCEDURE IDENTIFIER LEFTBRACKET bloqueParamSubprograma RIGHTBRACKET IS seccionTipos
								| FUNCTION IDENTIFIER LEFTBRACKET bloqueParamSubprograma RIGHTBRACKET error IS {:syntaxErrorManager.syntaxInfo("ERROR 00x: Error definición función, falta return");:};


bloqueParamSubprograma		::= bloqueParamSubprograma SEMICOLON listaIdentificadores COLON tipoPrimitivo
								| listaIdentificadores COLON tipoPrimitivo
								| empty;

// Bloque de sentencias
bloqueSentencias			::=  
								{:
									semanticErrorManager.semanticDebug("Sentencia: ");
								:} sentencia:sent SEMICOLON bloqueSentencias
								| empty;								

sentencia		::= expresion {: semanticErrorManager.semanticDebug("Sentencia -> Expresion"); :}  
					| sentenciaAsignacion {: semanticErrorManager.semanticDebug("Sentencia->SentenciaAsignación"); :}   
					| sentenciaIf {: semanticErrorManager.semanticDebug("Sentencia -> SentenciaIF"); :}  
					| {: semanticErrorManager.semanticDebug("Sentencia -> sentenciaIO"); :} sentenciaIO 
					| sentenciaReturn {: semanticErrorManager.semanticDebug("Sentencia -> SentenciaReturn"); :}  
					| sentenciaFor{: semanticErrorManager.semanticDebug("Sentencia -> SentenciaFor"); :}  ;


// Expresiones
expresion	::= expresionAritmetica:exprarit
				{:
					semanticErrorManager.semanticDebug("en Expresion -> ExpresionAritmetica: ");
					RESULT = exprarit;
				:}
				|expresionLogica:exprlog 
				{:
					semanticErrorManager.semanticDebug("en Expresion -> ExpresionLogica");
					RESULT = exprlog;
				:}  
				| LEFTBRACKET expresion:expr RIGHTBRACKET
				{:
					semanticErrorManager.semanticDebug("en Expresion -> (expresion) ");
					RESULT = expr;
				:}				 
				| sentenciaLlamadaSubprograma
				{:
					semanticErrorManager.semanticDebug("en Expresion -> SentenciaLlamadaSubprograma");
				:}
				
				| referencia:ref
				{:
				semanticErrorManager.semanticDebug("en Expresion -> Referencia, Id=" + ref.getName());
					String name = ref.getName();
					if(!scopeManager.containsSymbol(name))
					{
						semanticErrorManager.semanticFatalError("Error. Identificador no definido: " + name); 
						//+ ", [Line=" + id.getLine() + ",Col=" + id.getColumn() + "]");
					}
					else
					{	//Sí existe en la tabla de Símbolos					
						SymbolIF sId = scopeManager.searchSymbol(name);
						TypeIF type = sId.getType();
						RESULT = new Expresion(type);
					}
				
					
				:}
				| error SEMICOLON 
				{:
					syntaxErrorManager.syntaxInfo("Error sintáctico en Expresión");
				:};

expresionAritmetica ::= expresion:e1 PLUS expresion:e2
							{:
								semanticErrorManager.semanticDebug("En ExpresionAritmetica -> Expresion + Expresion");
								
//								//Comprobación de tipos sobre e1 y e2
//								TypeIF e1type = scopeManager.searchType("Integer");
//								TypeIF e2type = scopeManager.searchType("Integer");
//								semanticErrorManager.semanticDebug("Expresión Aritmética - Tipo de e1: " + e1type.getName());
//								semanticErrorManager.semanticDebug("Expresión Aritmética - Tipo de e2: " + e2type.getName());
//								if (e1type == e2type)
//								{
//									semanticErrorManager.semanticDebug("Expresión Aritmética - Tipos compatibles" );							
//								}
//								else semanticErrorManager.semanticFatalError ("Expresión Aritmética - Tipos incompatibles");

								ExpresionAritmetica exprarit = new ExpresionAritmetica(e1, e2);
								RESULT = exprarit; 
							:} 
						| NUMBER:num
						{:
							ExpresionAritmetica exprarit = new ExpresionAritmetica();
							exprarit.setValue(Integer.parseInt(num.getLexema()));
							semanticErrorManager.semanticDebug("En ExpresionAritmetica -> NUMBER");
						:}; 

expresionLogica		::= expresion:e1 OR expresion:e2
							{:
								ExpresionLogica exprlog = new ExpresionLogica(e1, e2);
								//Comprobación de tipos sobre e1 y e2
								//Generación de código para e1 OR e2							
								RESULT = exprlog;
							:} 
						| expresion:e1 GREATTHAN expresion:e2
							{:
								ExpresionLogica exprlog = new ExpresionLogica(e1, e2);
								//Comprobación de tipos sobre e1 y e2
								//Generación de código para e1 > e2
								RESULT = exprlog;
							:}
						| expresion:e1 EQUAL expresion:e2
							{:
								ExpresionLogica exprlog = new ExpresionLogica(e1, e2);
								//Comprobación de tipos sobre e1 y e2
								//Generación de código para e1 = e2
								RESULT=exprlog;
							:}
						| TRUE:tr 
						{:
							ExpresionLogica expr = new ExpresionLogica();
							expr.setValue(true);
							semanticErrorManager.semanticDebug("en ExpresiónLógica -> TRUE");
							RESULT = expr;
						:}
						| FALSE
						{:
							ExpresionLogica expr = new ExpresionLogica();
							expr.setValue(false);
							semanticErrorManager.semanticDebug("en ExpresiónLógica -> FALSE");
							RESULT = expr;
						:}
						;
						
referencia			::= referencia:refer POINT IDENTIFIER:id
								{: 
									String name = id.getLexema();
									semanticErrorManager.semanticDebug("En Referencia, ref.id: " + refer.getName() + "." + id.getLexema());
									
									TypeIF referType = refer.getType();
									if(referType instanceof TypeRecord)
									{
										TypeRecord tRec = (TypeRecord) referType;
										if(tRec.containsField(name)){
											//TypeIF innerType = tRec.getType();
											//RESULT = new Referencia(innerType, refer.getName());
										}
										else semanticErrorManager.semanticDebug("ERROR R001 - " + refer.getName() + " NO contiene campo " + name);
									}
									else semanticErrorManager.semanticDebug("ERROR R002-" + refer.getName() + ".Tipo=" + refer.getType() + " NO instancia de TypeRecord");
								:} 
								| IDENTIFIER:id
								{:	
								:};  
			
 
// Sentencia IO
sentenciaIO 	::= PUTLINE LEFTBRACKET 
					{:
						SentenciaIO sentenciaIO = new SentenciaIO();
						semanticErrorManager.semanticDebug(" sentenciaIO=PutLine(expresion)" );
						RESULT = sentenciaIO;
					:} expresion:expr RIGHTBRACKET
					| PUTLINE LEFTBRACKET STRING RIGHTBRACKET;
//					| error {:syntaxErrorManager.syntaxFatalError("ERROR S001: Error en sentencia Put_line"); :};


//Sentencia Asignacion
sentenciaAsignacion		::= IDENTIFIER:id ASSIGN expresion:exp
								{:
								semanticErrorManager.semanticDebug ("sentenciaAsignacion -> Id := expresion");
								//Comprobamos si se ha definido el símbolo en la TS anteriormente, si no, mostramos error semántico								
								ScopeIF scope = scopeManager.getCurrentScope();																
								SymbolTableIF tablaSimbolos = scope.getSymbolTable();										
								if(!tablaSimbolos.containsSymbol(id.getLexema())){
									semanticErrorManager.semanticFatalError("ERROR: Variable " + id.getLexema() + " not defined - Line=" + id.getLine() + ",Col=" + id.getColumn());
								}			
								else{
									//Comprobación de tipos.
									SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());
									TypeIF idtype = symbol.getType();
									semanticErrorManager.semanticDebug("El tipo de la variable: " + id.getLexema() + " es: " + idtype.getName());
									//TypeIF exptype = exp.getType();
								}
								SentenciaAsignacion asignacion = new SentenciaAsignacion();
								RESULT = asignacion;
								:}
							| expresionAccesoRegistro ASSIGN expresion;  
						
						
//Sentencia If
sentenciaIf			::= IF expresion THEN bloqueSentencias END IF 
						| IF expresion THEN bloqueSentencias ELSE bloqueSentencias END IF;

// Sentencia de retorno de función
sentenciaReturn	::= RETURN expresion;

// Sentencia de llamada a subprograma
sentenciaLlamadaSubprograma	::= IDENTIFIER LEFTBRACKET listaParametros RIGHTBRACKET;
listaParametros				::= listaParametros COMMA expresion | expresion | empty;


// Sentencia For
sentenciaFor	::=	FOR IDENTIFIER IN expresion DOUBLEPOINT expresion LOOP bloqueSentencias END LOOP;


empty ::= ;
